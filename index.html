<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>跳动的心特效</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="heartCanvas"></canvas>
    <script>
        const canvas = document.getElementById('heartCanvas');
        const ctx = canvas.getContext('2d');
        const CANVAS_WIDTH = window.innerWidth;
        const CANVAS_HEIGHT = window.innerHeight;
        const CANVAS_CENTER_X = CANVAS_WIDTH / 2;
        const CANVAS_CENTER_Y = CANVAS_HEIGHT / 2;
        const IMAGE_ENLARGE = 11;
        const HEART_COLOR = '#Fd798f';

        // 粒子类
        class Particle {
            constructor(x, y, size, color) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.speedX = (Math.random() - 0.5) * 3;
                this.speedY = (Math.random() - 0.5) * 3;
                this.life = Math.random() * 30 + 20;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life--;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        // 生成爱心坐标
        function heartFunction(t, shrinkRatio = IMAGE_ENLARGE) {
            const x = 16 * (Math.sin(t) ** 3);
            const y = -(15 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
            return {
                x: x * shrinkRatio + CANVAS_CENTER_X,
                y: y * shrinkRatio + CANVAS_CENTER_Y
            };
        }

        // 扩散算法
        function scatterInside(x, y, beta = 0.15) {
            const ratioX = -beta * Math.log(Math.random());
            const ratioY = -beta * Math.log(Math.random());
            return {
                x: x - ratioX * (x - CANVAS_CENTER_X),
                y: y - ratioY * (y - CANVAS_CENTER_Y)
            };
        }

        // 力场收缩
        function shrink(x, y, ratio) {
            const distance = Math.sqrt((x - CANVAS_CENTER_X) ** 2 + (y - CANVAS_CENTER_Y) ** 2);
            const force = -1 / (distance ** 0.6);
            return {
                x: x - ratio * force * (x - CANVAS_CENTER_X),
                y: y - ratio * force * (y - CANVAS_CENTER_Y)
            };
        }

        // 心跳类
        class Heart {
            constructor() {
                this.points = new Set();
                this.edgePoints = new Set();
                this.centerPoints = new Set();
                this.allParticles = [];
                this.build();
                this.animate();
            }

            build() {
                // 生成基础爱心点
                for (let i = 0; i < 2000; i++) {
                    const t = Math.random() * 2 * Math.PI;
                    const { x, y } = heartFunction(t);
                    this.points.add({ x, y });
                }

                // 边缘扩散
                for (const point of this.points) {
                    for (let i = 0; i < 3; i++) {
                        const { x, y } = scatterInside(point.x, point.y, 0.3);
                        this.edgePoints.add({ x, y });
                    }
                }

                // 中心扩散
                const pointsArray = Array.from(this.points);
                for (let i = 0; i < 4000; i++) {
                    const point = pointsArray[Math.floor(Math.random() * pointsArray.length)];
                    const { x, y } = scatterInside(point.x, point.y, 0.2);
                    this.centerPoints.add({ x, y });
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                const frame = Date.now() % 300;
                const ratio = 15 * (Math.sin(frame * Math.PI / 15));
                
                // 生成光晕粒子
                const haloParticles = [];
                for (let i = 0; i < 500; i++) {
                    const t = Math.random() * 2 * Math.PI;
                    const { x, y } = heartFunction(t, 11.5);
                    const { x: nx, y: ny } = shrink(x, y, Math.random() * 4 + 2);
                    haloParticles.push(new Particle(nx, ny, Math.random() * 2 + 1, 
                        `rgba(253, 121, 143, ${Math.random() * 0.5 + 0.3})`));
                }

                // 生成主体粒子
                const mainParticles = [];
                for (const point of this.points) {
                    const { x, y } = shrink(point.x, point.y, ratio);
                    mainParticles.push(new Particle(x, y, Math.random() * 2 + 1, HEART_COLOR));
                }

                // 生成边缘粒子
                for (const point of this.edgePoints) {
                    const { x, y } = shrink(point.x, point.y, ratio);
                    mainParticles.push(new Particle(x, y, Math.random() * 1.5 + 0.5, 
                        `rgba(253, 121, 143, ${Math.random() * 0.7 + 0.3})`));
                }

                // 绘制所有粒子
                [...haloParticles, ...mainParticles].forEach(particle => {
                    particle.update();
                    particle.draw();
                });
            }
        }

        // 初始化并运行
        window.addEventListener('load', () => {
            new Heart();
        });

        // 窗口大小调整
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            CANVAS_CENTER_X = window.innerWidth / 2;
            CANVAS_CENTER_Y = window.innerHeight / 2;
        });
    </script>
</body>
</html>
